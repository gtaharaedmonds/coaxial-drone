"""
This type stub file was generated by pyright.
"""

import os

from pymavlink.dialects.v20.ardupilotmega import MAVLink, MAVLink_message

'''
mavlink python utility functions

Copyright Andrew Tridgell 2011-2019
Released under GNU LGPL version 3 or later
'''
is_py3 = ...
UDP_MAX_PACKET_LEN = ...
mavfile_global = ...
default_native = ...
global_link_id = ...
if not'MAVLINK_DIALECT' in os.environ:
    ...
def mavlink10(): # -> bool:
    '''return True if using MAVLink 1.0 or later'''
    ...

def mavlink20(): # -> bool:
    '''return True if using MAVLink 2.0'''
    ...

def evaluate_expression(expression, vars, nocondition=...): # -> Any | None:
    '''evaluation an expression'''
    ...

def evaluate_condition(condition, vars): # -> Any | bool:
    '''evaluation a conditional (boolean) statement'''
    ...

def u_ord(c): # -> int:
    ...

class location:
    '''represent a GPS coordinate'''
    def __init__(self, lat, lng, alt=..., heading=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def add_message(messages, mtype, msg): # -> None:
    '''add a msg to array of messages, taking account of instance messages'''
    ...

def set_dialect(dialect): # -> None:
    '''set the MAVLink dialect to work with.
    For example, set_dialect("ardupilotmega")
    '''
    ...

class mavfile_state:
    '''state for a particular system id'''
    def __init__(self) -> None:
        ...
    


class param_state:
    '''state for a particular system id/component id pair'''
    def __init__(self) -> None:
        ...
    


class mavfile:
    '''a generic mavlink port'''
    def __init__(self, fd, address, source_system=..., source_component=..., notimestamps=..., input=..., use_native=...) -> None:
        self.mav: MAVLink
        ...
    
    @property
    def target_system(self): # -> int:
        ...
    
    @property
    def target_component(self): # -> Literal[0]:
        ...
    
    @target_system.setter
    def target_system(self, value): # -> None:
        ...
    
    @target_component.setter
    def target_component(self, value): # -> None:
        ...
    
    @property
    def params(self): # -> Any:
        ...
    
    @property
    def messages(self): # -> Any:
        ...
    
    @property
    def flightmode(self): # -> Any:
        ...
    
    @flightmode.setter
    def flightmode(self, value): # -> None:
        ...
    
    @property
    def vehicle_type(self): # -> Any:
        ...
    
    @vehicle_type.setter
    def vehicle_type(self, value): # -> None:
        ...
    
    @property
    def mav_type(self): # -> Any:
        ...
    
    @mav_type.setter
    def mav_type(self, value): # -> None:
        ...
    
    @property
    def base_mode(self): # -> Any:
        ...
    
    @base_mode.setter
    def base_mode(self, value): # -> None:
        ...
    
    def auto_mavlink_version(self, buf): # -> None:
        '''auto-switch mavlink protocol version'''
        ...
    
    def recv(self, n=...):
        '''default recv method'''
        ...
    
    def close(self, n=...):
        '''default close method'''
        ...
    
    def write(self, buf):
        '''default write method'''
        ...
    
    def select(self, timeout): # -> bool:
        '''wait for up to timeout seconds for more data'''
        ...
    
    def pre_message(self): # -> None:
        '''default pre message call'''
        ...
    
    def set_rtscts(self, enable): # -> None:
        '''enable/disable RTS/CTS if applicable'''
        ...
    
    def probably_vehicle_heartbeat(self, msg): # -> bool:
        ...
    
    def post_message(self, msg):
        '''default post message call'''
        ...
    
    def packet_loss(self): # -> float | Literal[0]:
        '''packet loss as a percentage'''
        ...
    
    def recv_msg(self):
        '''message receive routine'''
        ...
    
    def recv_match(self, condition=..., type=..., blocking=..., timeout=...) -> MAVLink_message:
        '''recv the next MAVLink message that matches the given condition
        type can be a string or a list of strings'''
        ...
    
    def check_condition(self, condition): # -> Any | bool:
        '''check if a condition is true'''
        ...
    
    def mavlink10(self): # -> bool:
        '''return True if using MAVLink 1.0 or later'''
        ...
    
    def mavlink20(self): # -> bool:
        '''return True if using MAVLink 2.0 or later'''
        ...
    
    def setup_logfile(self, logfile, mode=...): # -> None:
        '''start logging to the given logfile, with timestamps'''
        ...
    
    def setup_logfile_raw(self, logfile, mode=...): # -> None:
        '''start logging raw bytes to the given logfile, without timestamps'''
        ...
    
    def wait_heartbeat(self, blocking=..., timeout=...): # -> None:
        '''wait for a heartbeat so we know the target system IDs'''
        ...
    
    def param_fetch_all(self): # -> None:
        '''initiate fetch of all parameters'''
        ...
    
    def param_fetch_one(self, name): # -> None:
        '''initiate fetch of one parameter'''
        ...
    
    def time_since(self, mtype): # -> float | Any:
        '''return the time since the last message of type mtype was received'''
        ...
    
    def param_set_send(self, parm_name, parm_value, parm_type=...): # -> None:
        '''wrapper for parameter set'''
        ...
    
    def waypoint_request_list_send(self): # -> None:
        '''wrapper for waypoint_request_list_send'''
        ...
    
    def waypoint_clear_all_send(self): # -> None:
        '''wrapper for waypoint_clear_all_send'''
        ...
    
    def waypoint_request_send(self, seq): # -> None:
        '''wrapper for waypoint_request_send'''
        ...
    
    def waypoint_set_current_send(self, seq): # -> None:
        '''wrapper for waypoint_set_current_send'''
        ...
    
    def waypoint_current(self):
        '''return current waypoint'''
        ...
    
    def waypoint_count_send(self, seq): # -> None:
        '''wrapper for waypoint_count_send'''
        ...
    
    def set_mode_flag(self, flag, enable): # -> None:
        '''
        Enables/ disables MAV_MODE_FLAG
        @param flag The mode flag, 
          see MAV_MODE_FLAG enum
        @param enable Enable the flag, (True/False)
        '''
        ...
    
    def set_mode_auto(self): # -> None:
        '''enter auto mode'''
        ...
    
    def mode_mapping(self): # -> dict[str, Unknown] | dict[str, int] | None:
        '''return dictionary mapping mode names to numbers, or None if unknown'''
        ...
    
    def set_mode_apm(self, mode, custom_mode=..., custom_sub_mode=...): # -> None:
        '''enter arbitrary mode'''
        ...
    
    def set_mode_px4(self, mode, custom_mode, custom_sub_mode): # -> None:
        '''enter arbitrary mode'''
        ...
    
    def set_mode(self, mode, custom_mode=..., custom_sub_mode=...): # -> None:
        '''set arbitrary flight mode'''
        ...
    
    def set_mode_rtl(self): # -> None:
        '''enter RTL mode'''
        ...
    
    def set_mode_manual(self): # -> None:
        '''enter MANUAL mode'''
        ...
    
    def set_mode_fbwa(self): # -> None:
        '''enter FBWA mode'''
        ...
    
    def set_mode_loiter(self): # -> None:
        '''enter LOITER mode'''
        ...
    
    def set_servo(self, channel, pwm): # -> None:
        '''set a servo value'''
        ...
    
    def set_relay(self, relay_pin=..., state=...): # -> None:
        '''Set relay_pin to value of state'''
        ...
    
    def calibrate_level(self): # -> None:
        '''calibrate accels (1D version)'''
        ...
    
    def calibrate_pressure(self): # -> None:
        '''calibrate pressure'''
        ...
    
    def reboot_autopilot(self, hold_in_bootloader=...): # -> None:
        '''reboot the autopilot'''
        ...
    
    def wait_gps_fix(self): # -> None:
        ...
    
    def location(self, relative_alt=...): # -> location:
        '''return current location'''
        ...
    
    def arducopter_arm(self): # -> None:
        '''arm motors (arducopter only)'''
        ...
    
    def arducopter_disarm(self): # -> None:
        '''disarm motors (arducopter only)'''
        ...
    
    def motors_armed(self):
        '''return true if motors armed'''
        ...
    
    def motors_armed_wait(self): # -> None:
        '''wait for motors to be armed'''
        ...
    
    def motors_disarmed_wait(self): # -> None:
        '''wait for motors to be disarmed'''
        ...
    
    def field(self, type, field, default=...): # -> Any | None:
        '''convenient function for returning an arbitrary MAVLink
           field with a default'''
        ...
    
    def param(self, name, default=...): # -> Any | None:
        '''convenient function for returning an arbitrary MAVLink
           parameter with a default'''
        ...
    
    def setup_signing(self, secret_key, sign_outgoing=..., allow_unsigned_callback=..., initial_timestamp=..., link_id=...): # -> None:
        '''setup for MAVLink2 signing'''
        ...
    
    def disable_signing(self): # -> None:
        '''disable MAVLink2 signing'''
        ...
    


def set_close_on_exec(fd): # -> None:
    '''set the clone on exec flag on a file descriptor. Ignore exceptions'''
    ...

class FakeSerial:
    def __init__(self) -> None:
        ...
    
    def read(self, len): # -> Literal['']:
        ...
    
    def write(self, buf):
        ...
    
    def inWaiting(self): # -> Literal[0]:
        ...
    
    def close(self): # -> None:
        ...
    


class mavserial(mavfile):
    '''a serial mavlink port'''
    def __init__(self, device, baud=..., autoreconnect=..., source_system=..., source_component=..., use_native=..., force_connected=...) -> None:
        ...
    
    def set_rtscts(self, enable): # -> None:
        '''enable/disable RTS/CTS if applicable'''
        ...
    
    def set_baudrate(self, baudrate): # -> None:
        '''set baudrate'''
        ...
    
    def close(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes | Literal['']:
        ...
    
    def write(self, buf): # -> int | None:
        ...
    
    def reset(self): # -> bool:
        ...
    


class mavudp(mavfile):
    '''a UDP mavlink socket'''
    def __init__(self, device, input=..., broadcast=..., source_system=..., source_component=..., use_native=..., timeout=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes | Literal['']:
        ...
    
    def write(self, buf):
        ...
    
    def recv_msg(self): # -> Any:
        '''message receive routine for UDP link'''
        ...
    


class mavmcast(mavfile):
    '''a UDP multicast mavlink socket'''
    def __init__(self, device, broadcast=..., source_system=..., source_component=..., use_native=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes | Literal['']:
        ...
    
    def write(self, buf): # -> None:
        ...
    
    def recv_msg(self): # -> Any:
        '''message receive routine for UDP link'''
        ...
    


class mavtcp(mavfile):
    '''a TCP mavlink socket'''
    def __init__(self, device, autoreconnect=..., source_system=..., source_component=..., retries=..., use_native=...) -> None:
        ...
    
    def do_connect(self): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def handle_disconnect(self): # -> None:
        ...
    
    def handle_eof(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes | Literal['']:
        ...
    
    def write(self, buf): # -> None:
        ...
    
    def reconnect(self): # -> None:
        ...
    


class mavtcpin(mavfile):
    '''a TCP input mavlink socket'''
    def __init__(self, device, source_system=..., source_component=..., retries=..., use_native=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes | Literal['']:
        ...
    
    def write(self, buf): # -> None:
        ...
    


class mavlogfile(mavfile):
    '''a MAVLink logfile reader/writer'''
    def __init__(self, filename, planner_format=..., write=..., append=..., robust_parsing=..., notimestamps=..., source_system=..., source_component=..., use_native=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes:
        ...
    
    def write(self, buf): # -> None:
        ...
    
    def scan_timestamp(self, tbuf): # -> Any:
        '''scan forward looking in a tlog for a timestamp in a reasonable range'''
        ...
    
    def pre_message(self): # -> None:
        '''read timestamp if needed'''
        ...
    
    def post_message(self, msg): # -> None:
        '''add timestamp to message'''
        ...
    


class mavmmaplog(mavlogfile):
    '''a MAVLink log file accessed via mmap. Used for fast read-only
    access with low memory overhead where particular message types are wanted'''
    def __init__(self, filename, progress_callback=...) -> None:
        ...
    
    def rewind(self): # -> None:
        '''rewind to start of log'''
        ...
    
    def close(self): # -> None:
        ...
    
    def init_arrays(self, progress_callback=...): # -> None:
        '''initialise arrays for fast recv_match()'''
        ...
    
    def skip_to_type(self, type): # -> None:
        '''skip fwd to next msg matching given type set'''
        ...
    
    def recv_match(self, condition=..., type=..., blocking=..., timeout=...):
        '''recv the next message that matches the given condition
        type can be a string or a list of strings'''
        ...
    
    def flightmode_list(self): # -> list[Unknown]:
        '''return an array of tuples for all flightmodes in log. Tuple is (modestring, t0, t1)'''
        ...
    


class mavchildexec(mavfile):
    '''a MAVLink child processes reader/writer'''
    def __init__(self, filename, source_system=..., source_component=..., use_native=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def recv(self, n=...): # -> bytes | Literal['']:
        ...
    
    def write(self, buf): # -> None:
        ...
    


def mavlink_connection(device, baud=..., source_system=..., source_component=..., planner_format=..., write=..., append=..., robust_parsing=..., notimestamps=..., input=..., dialect=..., autoreconnect=..., zero_time_base=..., retries=..., use_native=..., force_connected=..., progress_callback=..., udp_timeout=..., **opts) -> mavfile:
    '''open a serial, UDP, TCP or file mavlink connection'''
    ...

class periodic_event:
    '''a class for fixed frequency events'''
    def __init__(self, frequency) -> None:
        ...
    
    def force(self): # -> None:
        '''force immediate triggering'''
        ...
    
    def trigger(self): # -> bool:
        '''return True if we should trigger now'''
        ...
    


def is_printable(c): # -> bool:
    '''see if a character is printable'''
    ...

def all_printable(buf): # -> bool:
    '''see if a string is all printable'''
    ...

class SerialPort:
    '''auto-detected serial port'''
    def __init__(self, device, description=..., hwid=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


def auto_detect_serial_win32(preferred_list=...): # -> list[Unknown]:
    '''try to auto-detect serial ports on win32'''
    ...

def auto_detect_serial_unix(preferred_list=...): # -> list[Unknown]:
    '''try to auto-detect serial ports on unix'''
    ...

def auto_detect_serial(preferred_list=...): # -> list[Unknown]:
    '''try to auto-detect serial port'''
    ...

def mode_string_v09(msg): # -> str | LiteralString:
    '''mode string for 0.9 protocol'''
    ...

mode_mapping_apm = ...
mode_mapping_acm = ...
mode_mapping_rover = ...
mode_mapping_tracker = ...
mode_mapping_sub = ...
mode_mapping_blimp = ...
AP_MAV_TYPE_MODE_MAP_DEFAULT = ...
mainstate_mapping_px4 = ...
def mode_string_px4(MainState): # -> str:
    ...

PX4_CUSTOM_MAIN_MODE_MANUAL = ...
PX4_CUSTOM_MAIN_MODE_ALTCTL = ...
PX4_CUSTOM_MAIN_MODE_POSCTL = ...
PX4_CUSTOM_MAIN_MODE_AUTO = ...
PX4_CUSTOM_MAIN_MODE_ACRO = ...
PX4_CUSTOM_MAIN_MODE_OFFBOARD = ...
PX4_CUSTOM_MAIN_MODE_STABILIZED = ...
PX4_CUSTOM_MAIN_MODE_RATTITUDE = ...
PX4_CUSTOM_SUB_MODE_OFFBOARD = ...
PX4_CUSTOM_SUB_MODE_AUTO_READY = ...
PX4_CUSTOM_SUB_MODE_AUTO_TAKEOFF = ...
PX4_CUSTOM_SUB_MODE_AUTO_LOITER = ...
PX4_CUSTOM_SUB_MODE_AUTO_MISSION = ...
PX4_CUSTOM_SUB_MODE_AUTO_RTL = ...
PX4_CUSTOM_SUB_MODE_AUTO_LAND = ...
PX4_CUSTOM_SUB_MODE_AUTO_RTGS = ...
PX4_CUSTOM_SUB_MODE_AUTO_FOLLOW_TARGET = ...
auto_mode_flags = ...
px4_map = ...
def interpret_px4_mode(base_mode, custom_mode): # -> Literal['MANUAL', 'ACRO', 'RATTITUDE', 'STABILIZED', 'ALTCTL', 'POSCTL', 'MISSION', 'TAKEOFF', 'LOITER', 'FOLLOWME', 'RTL', 'LAND', 'RTGS', 'OFFBOARD', 'UNKNOWN']:
    ...

def mode_mapping_byname(mav_type): # -> dict[str, int] | None:
    '''return dictionary mapping mode names to numbers, or None if unknown'''
    ...

def mode_mapping_bynumber(mav_type): # -> dict[int, str] | None:
    '''return dictionary mapping mode numbers to name, or None if unknown'''
    ...

def mode_string_v10(msg): # -> str:
    '''mode string for 1.0 protocol, from heartbeat'''
    ...

def mode_string_apm(mode_number): # -> str:
    '''return mode string for ArduPlane'''
    ...

def mode_string_acm(mode_number): # -> str:
    '''return mode string for ArduCopter'''
    ...

class x25crc:
    '''CRC-16/MCRF4XX - based on checksum.h from mavlink library'''
    def __init__(self, buf=...) -> None:
        ...
    
    def accumulate(self, buf): # -> None:
        '''add in some more bytes'''
        ...
    


class MavlinkSerialPort:
    '''an object that looks like a serial port, but
        transmits using mavlink SERIAL_CONTROL packets'''
    def __init__(self, portname, baudrate, devnum=..., devbaud=..., timeout=..., debug=...) -> None:
        ...
    
    def debug(self, s, level=...): # -> None:
        '''write some debug text'''
        ...
    
    def write(self, b): # -> None:
        '''write some bytes'''
        ...
    
    def read(self, n): # -> str:
        '''read some bytes'''
        ...
    
    def flushInput(self): # -> None:
        '''flush any pending input'''
        ...
    
    def setBaudrate(self, baudrate): # -> None:
        '''set baudrate'''
        ...
    


def decode_bitmask(messagetype, field, value): # -> list[Unknown]:
    class EnumBitInfo:
        ...
    
    

def dump_message_verbose(f, m):
    '''write an excruciatingly detailed dump of message m to file descriptor for a list of strings'''
    ...

if __name__ == '__main__':
    serial_list = ...

